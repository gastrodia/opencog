/*
 * @file tests/planning/CommanderServerUTest.cxxtest
 *
 * Copyright (C) 2016 OpenCog Foundation
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <cxxtest/TestSuite.h>

#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/util/Logger.h>
#include <opencog/truthvalue/TruthValue.h>
#include <opencog/commander/CommanderServer.h>
#include <opencog/commander/WebSocketIO/Client.h>
#include <stdio.h>
#include <map>
#include <pthread.h>
#include <unistd.h>

using namespace opencog;
using namespace std;

#define COMMANDER_TEST_PATH PROJECT_SOURCE_DIR "/tests/commander"
#define CHKERR                                 \
    TSM_ASSERT("Caught scm error during eval", \
               (false == _scm->eval_error()));

void *start_server(void *args)
{
    CommanderServer *_opr = new CommanderServer();
    _opr->start_server();
}

void *PrintHello(void *threadid)
{
    long tid;
    tid = (long)threadid;
    printf("Hello World! It's me, thread #%ld!\n", tid);
    pthread_exit(NULL);
}

class CommanderServerUTest : public CxxTest::TestSuite
{
  private:
    AtomSpace *_as;
    SchemeEval *_scm;

  public:
    CommanderServerUTest()
    {
        _as = new AtomSpace();
        _scm = new SchemeEval(_as);

        // The scheme environment is reset between each test.
        // Configure scheme load-paths that are common for all tests.
        // _scm->eval("(add-to-load-path \"/usr/local/share/opencog/scm\")");
        // CHKERR

        // // Load required modules for testing and populate the atomspace
        // _scm->eval("(use-modules (opencog) (opencog openpsi))");
        // CHKERR
        // _scm->eval("(load \"" OPENPSI_TEST_PATH "/rules.scm\")");
        // CHKERR

        logger().set_level(Logger::DEBUG);
        logger().set_print_level_flag(true);
        logger().set_print_to_stdout_flag(true);
    }

    ~CommanderServerUTest()
    {
        // Clean Up
        delete _as;
        _as = nullptr;
        delete _scm;
        _scm = nullptr;

        // Erase the log file if no assertions failed
        if (!CxxTest::TestTracker::tracker().suiteFailed())
            std::remove(logger().get_filename().c_str());
    }

    // Each test continuese from the state created by the previous one.
    void setUp() {}
    void tearDown() {}

    // Check the ctest foo?
    void test_foo()
    {
        logger().info("BEGIN TEST: %s", __FUNCTION__);

        CHKERR
        TSM_ASSERT_EQUALS("Expected `#t`", 1, 1);

        logger().info("END TEST: %s", __FUNCTION__);
    }

    // check start commander server
    void test_start_commander_server()
    {
        logger().info("BEGIN TEST: %s", __FUNCTION__);

        CHKERR
        pthread_t thread_number;
        //pthread_create(&thread_number, NULL, start_server , "hello!");
        pthread_create(&thread_number, NULL, start_server, (void *)2);
        sleep(1);
        auto client = new Client("127.0.0.1", 8000);
        client->on("connection", [client](JSON) {
            client->on("rpc-execute!", [&client](JSON data) {
                client->send("rpc-result!", std::string("") +
                                                "{\"method\":" + "\"foo\"" +
                                                ",\"guid\":" + "\"" + "abc" + "\"" +
                                                ",\"result\":" + "\"" + "hello world" + "\"" +
                                                ",\"params\":" + "[\"hello\"]" + "}");
            });
        });
        client->poll(200);
        cout << "sleep(10)" << endl;
        sleep(100);

        logger().info("END TEST: %s", __FUNCTION__);
    }

    void test_using_map_in_lambda()
    {
        logger().info("BEGIN TEST: %s", __FUNCTION__);
        map<string, string> tmap = {};

        cout << "tmap: " << &tmap << endl;
        auto test_lambda = [&tmap]() {
            cout << "tmap: " << &tmap << endl;
            //tmap.insert(std::pair<string, string>("abc", "cba"));
            tmap["abc"] = "cba";
            cout << tmap.at("abc") << endl;
            cout << "update tmap success! " << endl;
            //count << tmap.at(guid) << endl;
        };
        test_lambda();
        TSM_ASSERT_EQUALS("Expected `#t`", "cba", tmap.at("abc"));
        logger().info("END TEST: %s", __FUNCTION__);
    };
};
